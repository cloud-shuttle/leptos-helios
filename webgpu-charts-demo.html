<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helios WebGPU Charts Demo - Visual GPU Rendering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .webgpu-badge {
            display: inline-block;
            background: #ff6b35;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin: 10px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .demo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .demo-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .demo-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .demo-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .webgpu-canvas {
            width: 100%;
            height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: #f8f9fa;
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #555;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-success {
            background: #4CAF50;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .btn-warning {
            background: #ff9800;
        }

        .btn-warning:hover {
            background: #f57c00;
        }

        .performance-metrics {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4CAF50;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .metric-value {
            font-weight: bold;
            color: #4CAF50;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .status-supported {
            background: #4CAF50;
        }

        .status-unsupported {
            background: #f44336;
        }

        .status-loading {
            background: #ff9800;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .navigation {
            text-align: center;
            margin-bottom: 30px;
        }

        .nav-link {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            text-decoration: none;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            color: white;
            opacity: 0.8;
        }

        .github-link {
            color: white;
            text-decoration: none;
            font-weight: bold;
            transition: opacity 0.3s ease;
        }

        .github-link:hover {
            opacity: 0.7;
        }

        .console-output {
            background: #1a1a1a;
            color: #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #333;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .demo-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Helios WebGPU Charts Demo</h1>
            <p>High-Performance GPU-Accelerated Chart Rendering</p>
            <div class="webgpu-badge">üöÄ GPU Accelerated</div>
        </div>

        <div class="navigation">
            <a href="/" class="nav-link">üìä Canvas2D Demo</a>
            <a href="/webgpu" class="nav-link">‚ö° WebGPU Demo</a>
            <a href="/webgpu-charts" class="nav-link">üìà WebGPU Charts</a>
            <a href="/example" class="nav-link">üîß WASM Example</a>
        </div>

        <div class="demo-grid">
            <!-- WebGPU Status -->
            <div class="demo-card">
                <h3>üîç WebGPU Status</h3>
                <div class="performance-metrics">
                    <div class="metric">
                        <span>WebGPU Support:</span>
                        <span class="metric-value" id="webgpuSupport">Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Device Ready:</span>
                        <span class="metric-value" id="deviceReady">-</span>
                    </div>
                    <div class="metric">
                        <span>Render Context:</span>
                        <span class="metric-value" id="renderContext">-</span>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn" onclick="initializeWebGPU()">‚ö° Initialize WebGPU</button>
                    <button class="btn btn-success" onclick="testWebGPU()">üß™ Test WebGPU</button>
                </div>
                <div class="console-output" id="webgpuConsole">
                    WebGPU Charts Demo - Ready to initialize...
                </div>
            </div>

            <!-- Line Chart Demo -->
            <div class="demo-card">
                <h3>üìà Line Chart Rendering</h3>
                <canvas id="lineChartCanvas" class="webgpu-canvas" width="500" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Data Points:</label>
                        <input type="range" id="linePoints" min="100" max="10000" value="1000" step="100">
                        <span id="linePointsValue">1000</span>
                    </div>
                    <div class="control-group">
                        <label>Chart Type:</label>
                        <select id="lineType">
                            <option value="sine">Sine Wave</option>
                            <option value="cosine">Cosine Wave</option>
                            <option value="random">Random Data</option>
                            <option value="linear">Linear Growth</option>
                        </select>
                    </div>
                    <button class="btn" onclick="renderLineChart()">üìà Render Line Chart</button>
                    <button class="btn btn-success" onclick="testLineChart()">üß™ Test Line Chart</button>
                </div>
                <div class="performance-metrics" id="lineChartMetrics">
                    <div class="metric">
                        <span>Render Time:</span>
                        <span class="metric-value" id="lineChartRenderTime">-</span>
                    </div>
                    <div class="metric">
                        <span>Points Rendered:</span>
                        <span class="metric-value" id="lineChartPoints">-</span>
                    </div>
                    <div class="metric">
                        <span>FPS:</span>
                        <span class="metric-value" id="lineChartFPS">-</span>
                    </div>
                </div>
            </div>

            <!-- Bar Chart Demo -->
            <div class="demo-card">
                <h3>üìä Bar Chart Rendering</h3>
                <canvas id="barChartCanvas" class="webgpu-canvas" width="500" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Bar Count:</label>
                        <input type="range" id="barCount" min="5" max="50" value="20" step="1">
                        <span id="barCountValue">20</span>
                    </div>
                    <div class="control-group">
                        <label>Orientation:</label>
                        <select id="barOrientation">
                            <option value="vertical">Vertical</option>
                            <option value="horizontal">Horizontal</option>
                        </select>
                    </div>
                    <button class="btn" onclick="renderBarChart()">üìä Render Bar Chart</button>
                    <button class="btn btn-success" onclick="testBarChart()">üß™ Test Bar Chart</button>
                </div>
                <div class="performance-metrics" id="barChartMetrics">
                    <div class="metric">
                        <span>Render Time:</span>
                        <span class="metric-value" id="barChartRenderTime">-</span>
                    </div>
                    <div class="metric">
                        <span>Bars Rendered:</span>
                        <span class="metric-value" id="barChartBars">-</span>
                    </div>
                    <div class="metric">
                        <span>FPS:</span>
                        <span class="metric-value" id="barChartFPS">-</span>
                    </div>
                </div>
            </div>

            <!-- Scatter Plot Demo -->
            <div class="demo-card">
                <h3>üîµ Scatter Plot Rendering</h3>
                <canvas id="scatterCanvas" class="webgpu-canvas" width="500" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Point Count:</label>
                        <input type="range" id="scatterPoints" min="100" max="5000" value="1000" step="100">
                        <span id="scatterPointsValue">1000</span>
                    </div>
                    <div class="control-group">
                        <label>Point Size:</label>
                        <input type="range" id="pointSize" min="1" max="10" value="3" step="1">
                        <span id="pointSizeValue">3</span>
                    </div>
                    <button class="btn" onclick="renderScatterPlot()">üîµ Render Scatter Plot</button>
                    <button class="btn btn-success" onclick="testScatterPlot()">üß™ Test Scatter Plot</button>
                </div>
                <div class="performance-metrics" id="scatterMetrics">
                    <div class="metric">
                        <span>Render Time:</span>
                        <span class="metric-value" id="scatterRenderTime">-</span>
                    </div>
                    <div class="metric">
                        <span>Points Rendered:</span>
                        <span class="metric-value" id="scatterPointsRendered">-</span>
                    </div>
                    <div class="metric">
                        <span>FPS:</span>
                        <span class="metric-value" id="scatterFPS">-</span>
                    </div>
                </div>
            </div>

            <!-- Performance Benchmark -->
            <div class="demo-card">
                <h3>‚ö° Performance Benchmark</h3>
                <canvas id="benchmarkCanvas" class="webgpu-canvas" width="500" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Benchmark Size:</label>
                        <select id="benchmarkSize">
                            <option value="1000">1K points</option>
                            <option value="10000">10K points</option>
                            <option value="100000">100K points</option>
                            <option value="1000000">1M points</option>
                        </select>
                    </div>
                    <button class="btn btn-warning" onclick="runPerformanceBenchmark()">üèÉ‚Äç‚ôÇÔ∏è Run Benchmark</button>
                </div>
                <div class="performance-metrics" id="benchmarkMetrics">
                    <div class="metric">
                        <span>Render Time:</span>
                        <span class="metric-value" id="benchmarkRenderTime">-</span>
                    </div>
                    <div class="metric">
                        <span>Throughput:</span>
                        <span class="metric-value" id="benchmarkThroughput">-</span>
                    </div>
                    <div class="metric">
                        <span>FPS:</span>
                        <span class="metric-value" id="benchmarkFPS">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Built with ‚ù§Ô∏è using WebGPU and Rust</p>
            <p><a href="https://github.com/your-org/leptos-helios" class="github-link">View on GitHub</a></p>
        </div>
    </div>

    <script>
        // WebGPU Charts Demo Implementation
        class WebGPUChartsDemo {
            constructor() {
                this.adapter = null;
                this.device = null;
                this.context = null;
                this.initialized = false;
                this.shaders = new Map();
                this.pipelines = new Map();
                this.buffers = new Map();
            }

            // Log to console
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚úÖ';
                const consoleOutput = document.getElementById('webgpuConsole');
                consoleOutput.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
                console.log(message);
            }

            // Check WebGPU support
            async checkSupport() {
                this.log('Checking WebGPU support...');

                if (!navigator.gpu) {
                    this.log('WebGPU not supported in this browser', 'error');
                    return false;
                }

                try {
                    this.adapter = await navigator.gpu.requestAdapter();
                    if (!this.adapter) {
                        this.log('No WebGPU adapter found', 'error');
                        return false;
                    }

                    this.log('WebGPU adapter found: ' + (this.adapter.info?.description || 'Unknown'));
                    return true;
                } catch (error) {
                    this.log('WebGPU support check failed: ' + error.message, 'error');
                    return false;
                }
            }

            // Initialize WebGPU
            async initialize() {
                if (this.initialized) {
                    this.log('WebGPU already initialized');
                    return true;
                }

                this.log('Initializing WebGPU...');

                if (!this.adapter) {
                    const supported = await this.checkSupport();
                    if (!supported) return false;
                }

                try {
                    this.device = await this.adapter.requestDevice();
                    this.log('WebGPU device created successfully');

                    // Update UI
                    document.getElementById('webgpuSupport').innerHTML =
                        '<span class="status-indicator status-supported"></span>Supported';
                    document.getElementById('deviceReady').textContent = 'Yes';

                    this.initialized = true;
                    this.log('WebGPU initialization complete');
                    return true;
                } catch (error) {
                    this.log('WebGPU initialization failed: ' + error.message, 'error');
                    return false;
                }
            }

            // Create canvas context
            async createCanvasContext(canvasId) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    this.log(`Canvas ${canvasId} not found`, 'error');
                    return null;
                }

                try {
                    const context = canvas.getContext('webgpu');
                    if (!context) {
                        this.log(`WebGPU context not supported for ${canvasId}`, 'error');
                        return null;
                    }

                    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
                    context.configure({
                        device: this.device,
                        format: canvasFormat,
                    });

                    this.log(`WebGPU context created for ${canvasId}`);
                    return context;
                } catch (error) {
                    this.log(`Failed to create WebGPU context for ${canvasId}: ${error.message}`, 'error');
                    return null;
                }
            }

            // Compile shader
            async compileShader(name, vertexSource, fragmentSource) {
                if (!this.device) {
                    this.log('WebGPU device not initialized', 'error');
                    return false;
                }

                this.log(`Compiling shader: ${name}`);
                const startTime = performance.now();

                try {
                    const vertexShader = this.device.createShaderModule({
                        code: vertexSource
                    });

                    const fragmentShader = this.device.createShaderModule({
                        code: fragmentSource
                    });

                    this.shaders.set(name, { vertex: vertexShader, fragment: fragmentShader });

                    const compileTime = performance.now() - startTime;
                    this.log(`Shader compiled successfully in ${compileTime.toFixed(2)}ms`);

                    return true;
                } catch (error) {
                    this.log(`Shader compilation failed: ${error.message}`, 'error');
                    return false;
                }
            }

            // Create render pipeline
            async createPipeline(name, type = 'line') {
                if (!this.device || !this.shaders.has('default')) {
                    this.log('Device or shader not ready', 'error');
                    return false;
                }

                this.log(`Creating ${type} pipeline: ${name}`);
                const startTime = performance.now();

                try {
                    const shaderName = type === 'point' ? 'point' : 'default';
                    const shader = this.shaders.get(shaderName);

                    const pipeline = this.device.createRenderPipeline({
                        layout: 'auto',
                        vertex: {
                            module: shader.vertex,
                            entryPoint: 'vs_main',
                            buffers: [{
                                arrayStride: 8, // 2 floats * 4 bytes
                                attributes: [{
                                    format: 'float32x2',
                                    offset: 0,
                                    shaderLocation: 0
                                }]
                            }]
                        },
                        fragment: {
                            module: shader.fragment,
                            entryPoint: 'fs_main',
                            targets: [{
                                format: 'bgra8unorm'
                            }]
                        },
                        primitive: {
                            topology: type === 'line' ? 'line-strip' :
                                     type === 'point' ? 'point-list' : 'triangle-list'
                        }
                    });

                    this.pipelines.set(name, pipeline);

                    const createTime = performance.now() - startTime;
                    this.log(`Pipeline created successfully in ${createTime.toFixed(2)}ms`);

                    return true;
                } catch (error) {
                    this.log(`Pipeline creation failed: ${error.message}`, 'error');
                    return false;
                }
            }

            // Generate test data
            generateTestData(pattern, count) {
                const vertices = [];

                for (let i = 0; i < count; i++) {
                    const x = (i / count) * 2 - 1; // -1 to 1
                    let y;

                    switch (pattern) {
                        case 'sine':
                            y = Math.sin(i * 0.1) * 0.5;
                            break;
                        case 'cosine':
                            y = Math.cos(i * 0.1) * 0.5;
                            break;
                        case 'random':
                            y = (Math.random() - 0.5) * 2;
                            break;
                        case 'linear':
                            y = (i / count) * 2 - 1;
                            break;
                        default:
                            y = Math.sin(i * 0.1) * 0.5;
                    }

                    vertices.push([x, y]);
                }

                return vertices;
            }

            // Render line chart
            async renderLineChart(canvasId, pointCount, type = 'sine') {
                if (!this.device) {
                    this.log('WebGPU device not initialized', 'error');
                    return false;
                }

                const startTime = performance.now();
                this.log(`Rendering line chart with ${pointCount} points`);

                try {
                    const context = await this.createCanvasContext(canvasId);
                    if (!context) return false;

                    const vertices = this.generateTestData(type, pointCount);

                    // Create vertex buffer
                    const vertexBuffer = this.device.createBuffer({
                        size: vertices.length * 8,
                        usage: GPUBufferUsage.VERTEX,
                        mappedAtCreation: true
                    });

                    const arrayBuffer = vertexBuffer.getMappedRange();
                    const floatArray = new Float32Array(arrayBuffer);

                    for (let i = 0; i < vertices.length; i++) {
                        floatArray[i * 2] = vertices[i][0];
                        floatArray[i * 2 + 1] = vertices[i][1];
                    }

                    vertexBuffer.unmap();

                    // Create render pipeline if not exists
                    if (!this.pipelines.has('line')) {
                        await this.createPipeline('line', 'line');
                    }

                    // Render
                    const commandEncoder = this.device.createCommandEncoder();
                    const textureView = context.getCurrentTexture().createView();

                    const renderPassDescriptor = {
                        colorAttachments: [{
                            view: textureView,
                            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store'
                        }]
                    };

                    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                    passEncoder.setPipeline(this.pipelines.get('line'));
                    passEncoder.setVertexBuffer(0, vertexBuffer);
                    passEncoder.draw(vertices.length);
                    passEncoder.end();

                    this.device.queue.submit([commandEncoder.finish()]);

                    const endTime = performance.now();
                    const renderTime = endTime - startTime;
                    const fps = 1000 / renderTime;

                    this.log(`Line chart rendered in ${renderTime.toFixed(2)}ms (${fps.toFixed(1)} FPS)`);

                    // Update UI
                    document.getElementById('lineChartRenderTime').textContent = `${renderTime.toFixed(2)}ms`;
                    document.getElementById('lineChartPoints').textContent = pointCount.toString();
                    document.getElementById('lineChartFPS').textContent = `${fps.toFixed(1)} FPS`;

                    return true;
                } catch (error) {
                    this.log(`Line chart rendering failed: ${error.message}`, 'error');
                    return false;
                }
            }

            // Render bar chart
            async renderBarChart(canvasId, barCount, orientation = 'vertical') {
                if (!this.device) {
                    this.log('WebGPU device not initialized', 'error');
                    return false;
                }

                const startTime = performance.now();
                this.log(`Rendering bar chart with ${barCount} bars`);

                try {
                    const context = await this.createCanvasContext(canvasId);
                    if (!context) return false;

                    // Generate bar data
                    const vertices = [];
                    for (let i = 0; i < barCount; i++) {
                        const value = Math.random() * 0.8 + 0.1; // 0.1 to 0.9
                        const x = (i / barCount) * 2 - 1;

                        if (orientation === 'vertical') {
                            // Vertical bars - 2 triangles per bar
                            const barWidth = 1.6 / barCount; // Make bars wider

                            // First triangle (bottom-left, top-left, top-right)
                            vertices.push([x, -1]);
                            vertices.push([x, -1 + value * 2]);
                            vertices.push([x + barWidth, -1 + value * 2]);

                            // Second triangle (bottom-left, top-right, bottom-right)
                            vertices.push([x, -1]);
                            vertices.push([x + barWidth, -1 + value * 2]);
                            vertices.push([x + barWidth, -1]);
                        } else {
                            // Horizontal bars - 2 triangles per bar
                            const y = (i / barCount) * 2 - 1;
                            const barHeight = 1.6 / barCount; // Make bars taller

                            // First triangle (left, top-left, top-right)
                            vertices.push([-1, y]);
                            vertices.push([-1, y + barHeight]);
                            vertices.push([-1 + value * 2, y + barHeight]);

                            // Second triangle (left, top-right, right)
                            vertices.push([-1, y]);
                            vertices.push([-1 + value * 2, y + barHeight]);
                            vertices.push([-1 + value * 2, y]);
                        }
                    }

                    // Create vertex buffer
                    const vertexBuffer = this.device.createBuffer({
                        size: vertices.length * 8,
                        usage: GPUBufferUsage.VERTEX,
                        mappedAtCreation: true
                    });

                    const arrayBuffer = vertexBuffer.getMappedRange();
                    const floatArray = new Float32Array(arrayBuffer);

                    for (let i = 0; i < vertices.length; i++) {
                        floatArray[i * 2] = vertices[i][0];
                        floatArray[i * 2 + 1] = vertices[i][1];
                    }

                    vertexBuffer.unmap();

                    // Create render pipeline if not exists
                    if (!this.pipelines.has('bar')) {
                        await this.createPipeline('bar', 'triangle');
                    }

                    // Render
                    const commandEncoder = this.device.createCommandEncoder();
                    const textureView = context.getCurrentTexture().createView();

                    const renderPassDescriptor = {
                        colorAttachments: [{
                            view: textureView,
                            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store'
                        }]
                    };

                    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                    passEncoder.setPipeline(this.pipelines.get('bar'));
                    passEncoder.setVertexBuffer(0, vertexBuffer);
                    passEncoder.draw(vertices.length);
                    passEncoder.end();

                    this.device.queue.submit([commandEncoder.finish()]);

                    const endTime = performance.now();
                    const renderTime = endTime - startTime;
                    const fps = 1000 / renderTime;

                    this.log(`Bar chart rendered in ${renderTime.toFixed(2)}ms (${fps.toFixed(1)} FPS)`);

                    // Update UI
                    document.getElementById('barChartRenderTime').textContent = `${renderTime.toFixed(2)}ms`;
                    document.getElementById('barChartBars').textContent = barCount.toString();
                    document.getElementById('barChartFPS').textContent = `${fps.toFixed(1)} FPS`;

                    return true;
                } catch (error) {
                    this.log(`Bar chart rendering failed: ${error.message}`, 'error');
                    return false;
                }
            }

            // Render scatter plot
            async renderScatterPlot(canvasId, pointCount, pointSize = 3) {
                if (!this.device) {
                    this.log('WebGPU device not initialized', 'error');
                    return false;
                }

                const startTime = performance.now();
                this.log(`Rendering scatter plot with ${pointCount} points`);

                try {
                    const context = await this.createCanvasContext(canvasId);
                    if (!context) return false;

                    // Generate scatter data
                    const vertices = [];
                    for (let i = 0; i < pointCount; i++) {
                        const x = (Math.random() - 0.5) * 2;
                        const y = (Math.random() - 0.5) * 2;

                        // Create small squares for each point using 2 triangles (6 vertices)
                        const size = pointSize / 50; // Make points more visible
                        const scaledX = x * 0.9;
                        const scaledY = y * 0.9;

                        // First triangle (bottom-left, top-left, top-right)
                        vertices.push([scaledX - size, scaledY - size]);
                        vertices.push([scaledX - size, scaledY + size]);
                        vertices.push([scaledX + size, scaledY + size]);

                        // Second triangle (bottom-left, top-right, bottom-right)
                        vertices.push([scaledX - size, scaledY - size]);
                        vertices.push([scaledX + size, scaledY + size]);
                        vertices.push([scaledX + size, scaledY - size]);
                    }

                    // Create vertex buffer
                    const vertexBuffer = this.device.createBuffer({
                        size: vertices.length * 8,
                        usage: GPUBufferUsage.VERTEX,
                        mappedAtCreation: true
                    });

                    const arrayBuffer = vertexBuffer.getMappedRange();
                    const floatArray = new Float32Array(arrayBuffer);

                    for (let i = 0; i < vertices.length; i++) {
                        floatArray[i * 2] = vertices[i][0];
                        floatArray[i * 2 + 1] = vertices[i][1];
                    }

                    vertexBuffer.unmap();

                    // Create render pipeline if not exists
                    if (!this.pipelines.has('scatter')) {
                        await this.createPipeline('scatter', 'triangle');
                    }

                    // Render
                    const commandEncoder = this.device.createCommandEncoder();
                    const textureView = context.getCurrentTexture().createView();

                    const renderPassDescriptor = {
                        colorAttachments: [{
                            view: textureView,
                            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store'
                        }]
                    };

                    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                    passEncoder.setPipeline(this.pipelines.get('scatter'));
                    passEncoder.setVertexBuffer(0, vertexBuffer);
                    passEncoder.draw(vertices.length);
                    passEncoder.end();

                    this.device.queue.submit([commandEncoder.finish()]);

                    const endTime = performance.now();
                    const renderTime = endTime - startTime;
                    const fps = 1000 / renderTime;

                    this.log(`Scatter plot rendered in ${renderTime.toFixed(2)}ms (${fps.toFixed(1)} FPS)`);

                    // Update UI
                    document.getElementById('scatterRenderTime').textContent = `${renderTime.toFixed(2)}ms`;
                    document.getElementById('scatterPointsRendered').textContent = pointCount.toString();
                    document.getElementById('scatterFPS').textContent = `${fps.toFixed(1)} FPS`;

                    return true;
                } catch (error) {
                    this.log(`Scatter plot rendering failed: ${error.message}`, 'error');
                    return false;
                }
            }

            // Run performance benchmark
            async runBenchmark(canvasId, size) {
                this.log(`Running performance benchmark with ${size} points`);
                const startTime = performance.now();

                try {
                    const success = await this.renderLineChart(canvasId, size, 'sine');

                    if (success) {
                        const endTime = performance.now();
                        const renderTime = endTime - startTime;
                        const throughput = (size * 8 / 1_000_000) / (renderTime / 1000);
                        const fps = 1000 / renderTime;

                        this.log(`Benchmark completed: ${renderTime.toFixed(2)}ms, ${throughput.toFixed(2)} MB/s, ${fps.toFixed(1)} FPS`);

                        // Update UI
                        document.getElementById('benchmarkRenderTime').textContent = `${renderTime.toFixed(2)}ms`;
                        document.getElementById('benchmarkThroughput').textContent = `${throughput.toFixed(2)} MB/s`;
                        document.getElementById('benchmarkFPS').textContent = `${fps.toFixed(1)} FPS`;

                        return { renderTime, throughput, fps };
                    }
                    return null;
                } catch (error) {
                    this.log(`Benchmark failed: ${error.message}`, 'error');
                    return null;
                }
            }
        }

        // Global WebGPU demo instance
        const webgpuChartsDemo = new WebGPUChartsDemo();

        // UI Functions
        async function initializeWebGPU() {
            const success = await webgpuChartsDemo.initialize();
            if (success) {
                // Compile default shader
                const vertexShader = `@vertex
fn vs_main(@location(0) position: vec2<f32>) -> @builtin(position) vec4<f32> {
    return vec4<f32>(position, 0.0, 1.0);
}`;

                const fragmentShader = `@fragment
fn fs_main() -> @location(0) vec4<f32> {
    return vec4<f32>(0.0, 0.5, 1.0, 1.0);
}`;

                // Create point shader for scatter plots
                const pointVertexShader = `@vertex
fn vs_main(@location(0) position: vec2<f32>) -> @builtin(position) vec4<f32> {
    return vec4<f32>(position, 0.0, 1.0);
}`;

                const pointFragmentShader = `@fragment
fn fs_main() -> @location(0) vec4<f32> {
    return vec4<f32>(0.2, 0.6, 1.0, 1.0);
}`;

                await webgpuChartsDemo.compileShader('default', vertexShader, fragmentShader);
                await webgpuChartsDemo.compileShader('point', pointVertexShader, pointFragmentShader);
                document.getElementById('renderContext').textContent = 'Ready';
            }
        }

        async function renderLineChart() {
            const pointCount = parseInt(document.getElementById('linePoints').value);
            const chartType = document.getElementById('lineType').value;
            await webgpuChartsDemo.renderLineChart('lineChartCanvas', pointCount, chartType);
        }

        async function renderBarChart() {
            const barCount = parseInt(document.getElementById('barCount').value);
            const orientation = document.getElementById('barOrientation').value;
            await webgpuChartsDemo.renderBarChart('barChartCanvas', barCount, orientation);
        }

        async function renderScatterPlot() {
            const pointCount = parseInt(document.getElementById('scatterPoints').value);
            const pointSize = parseInt(document.getElementById('pointSize').value);
            await webgpuChartsDemo.renderScatterPlot('scatterCanvas', pointCount, pointSize);
        }

        async function runPerformanceBenchmark() {
            const size = parseInt(document.getElementById('benchmarkSize').value);
            await webgpuChartsDemo.runBenchmark('benchmarkCanvas', size);
        }

        // Test functions
        async function testWebGPU() {
            const supported = await webgpuChartsDemo.checkSupport();
            if (supported) {
                await initializeWebGPU();
            }
        }

        async function testLineChart() {
            await renderLineChart();
        }

        async function testBarChart() {
            await renderBarChart();
        }

        async function testScatterPlot() {
            await renderScatterPlot();
        }

        // Event listeners
        document.getElementById('linePoints').addEventListener('input', (e) => {
            document.getElementById('linePointsValue').textContent = e.target.value;
        });

        document.getElementById('barCount').addEventListener('input', (e) => {
            document.getElementById('barCountValue').textContent = e.target.value;
        });

        document.getElementById('scatterPoints').addEventListener('input', (e) => {
            document.getElementById('scatterPointsValue').textContent = e.target.value;
        });

        document.getElementById('pointSize').addEventListener('input', (e) => {
            document.getElementById('pointSizeValue').textContent = e.target.value;
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            webgpuChartsDemo.log('WebGPU Charts Demo initialized');
            testWebGPU();
        });
    </script>
</body>
</html>
