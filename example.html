<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helios Visualization Library - Working Example</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        .demo-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            background: #2d5a2d;
            border: 1px solid #4a7c4a;
        }
        .error {
            background: #5a2d2d;
            border: 1px solid #7c4a4a;
        }
        .loading {
            background: #2d4a5a;
            border: 1px solid #4a6a7c;
        }
        pre {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        button {
            background: #00d4ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #00b8e6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Helios Visualization Library</h1>
            <p>High-Performance Rust Visualization for the Web</p>
        </div>

        <div class="demo-section">
            <h2>WASM Module Status</h2>
            <div id="status" class="status loading">Loading WASM module...</div>
        </div>

        <div class="demo-section">
            <h2>Function Tests</h2>
            <button onclick="testGreet()">Test Greet Function</button>
            <button onclick="testDataProcessing()">Test Data Processing</button>
            <button onclick="testChartCreation()">Test Chart Creation</button>
            <button onclick="testWebGPU()">Test WebGPU Support</button>
            <button onclick="renderLineChart()" style="background: #00d4ff;">üìà Line Chart</button>
            <button onclick="renderBarChart()" style="background: #ff6b6b;">üìä Bar Chart</button>
            <button onclick="renderScatterChart()" style="background: #51cf66;">üîµ Scatter Plot</button>
            <button onclick="renderAreaChart()" style="background: #ffd43b;">üìà Area Chart</button>
            <div id="results"></div>
        </div>

        <div class="demo-section">
            <h2>Chart Visualization</h2>
            <canvas id="chartCanvas" width="800" height="400" style="border: 1px solid #333; background: #1a1a1a; border-radius: 4px;"></canvas>
            <div id="chartInfo" style="margin-top: 10px; font-size: 14px; color: #888;"></div>
        </div>

        <div class="demo-section">
            <h2>Console Output</h2>
            <pre id="console-output"></pre>
        </div>
    </div>

    <script type="module">
        import init, { greet, process_data, create_simple_chart, test_webgpu_support } from './helios-app/pkg/leptos_helios_app.js';

        let wasmModule = null;
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        const consoleOutput = document.getElementById('console-output');

        // Capture console output
        const originalLog = console.log;
        const originalError = console.error;

        function addToConsole(message, type = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : '‚úÖ';
            consoleOutput.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        console.log = function(...args) {
            originalLog.apply(console, args);
            addToConsole(args.join(' '), 'log');
        };

        console.error = function(...args) {
            originalError.apply(console, args);
            addToConsole(args.join(' '), 'error');
        };

        async function initializeWasm() {
            try {
                console.log('Initializing WASM module...');
                wasmModule = await init();
                console.log('WASM module initialized successfully!');

                statusDiv.className = 'status success';
                statusDiv.textContent = '‚úÖ WASM module loaded successfully!';

                // Test basic functionality
                testGreet();

                // Automatically create and render a chart
                setTimeout(() => {
                    renderBarChart(); // Start with a colorful bar chart
                }, 1000);

            } catch (error) {
                console.error('Failed to initialize WASM module:', error);
                statusDiv.className = 'status error';
                statusDiv.textContent = '‚ùå Failed to load WASM module: ' + error.message;
            }
        }

        function testGreet() {
            if (!wasmModule) {
                resultsDiv.innerHTML = '<div class="status error">WASM module not loaded</div>';
                return;
            }

            try {
                const result = greet('Helios User');
                console.log('Greet function result:', result);
                resultsDiv.innerHTML = `<div class="status success">Greet: ${result}</div>`;
            } catch (error) {
                console.error('Greet function error:', error);
                resultsDiv.innerHTML = `<div class="status error">Greet error: ${error.message}</div>`;
            }
        };

        function testDataProcessing() {
            if (!wasmModule) {
                resultsDiv.innerHTML = '<div class="status error">WASM module not loaded</div>';
                return;
            }

            try {
                const result = process_data('hello world from helios');
                console.log('Data processing result:', result);
                resultsDiv.innerHTML = `<div class="status success">Data Processing: ${result}</div>`;
            } catch (error) {
                console.error('Data processing error:', error);
                resultsDiv.innerHTML = `<div class="status error">Data processing error: ${error.message}</div>`;
            }
        };

        function testChartCreation() {
            if (!wasmModule) {
                resultsDiv.innerHTML = '<div class="status error">WASM module not loaded</div>';
                return;
            }

            try {
                const chartJson = create_simple_chart();
                console.log('Chart creation result:', chartJson);

                // Parse the chart data
                const chartData = JSON.parse(chartJson);

                // Render the chart visually
                renderChart(chartData);

                resultsDiv.innerHTML = `
                    <div class="status success">Chart Created Successfully!</div>
                    <pre>${JSON.stringify(chartData, null, 2)}</pre>
                `;
            } catch (error) {
                console.error('Chart creation error:', error);
                resultsDiv.innerHTML = `<div class="status error">Chart creation error: ${error.message}</div>`;
            }
        };

        function renderChart(chartData, chartType = 'line') {
            const canvas = document.getElementById('chartCanvas');
            const ctx = canvas.getContext('2d');
            const chartInfo = document.getElementById('chartInfo');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set up chart dimensions
            const margin = 60;
            const chartWidth = canvas.width - 2 * margin;
            const chartHeight = canvas.height - 2 * margin;

            // Get data
            const labels = chartData.data.labels;
            const dataset = chartData.data.datasets[0];
            const data = dataset.data;

            // Find min/max values
            const minValue = Math.min(...data);
            const maxValue = Math.max(...data);
            const valueRange = maxValue - minValue;

            // Draw background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, canvas.height - margin);
            ctx.stroke();

            // X-axis
            ctx.beginPath();
            ctx.moveTo(margin, canvas.height - margin);
            ctx.lineTo(canvas.width - margin, canvas.height - margin);
            ctx.stroke();

            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.setLineDash([2, 2]);
            ctx.lineWidth = 1;

            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = margin + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(canvas.width - margin, y);
                ctx.stroke();
            }

            // Vertical grid lines
            for (let i = 0; i < labels.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, canvas.height - margin);
                ctx.stroke();
            }

            ctx.setLineDash([]);

            // Render based on chart type
            switch (chartType) {
                case 'line':
                    renderLineChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange);
                    break;
                case 'bar':
                    renderBarChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange);
                    break;
                case 'scatter':
                    renderScatterChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange);
                    break;
                case 'area':
                    renderAreaChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange);
                    break;
            }

            // Draw labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';

            // X-axis labels
            for (let i = 0; i < labels.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                ctx.fillText(labels[i], x, canvas.height - margin + 20);
            }

            // Y-axis labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = minValue + (valueRange / 5) * i;
                const y = canvas.height - margin - (chartHeight / 5) * i;
                ctx.fillText(value.toFixed(1), margin - 10, y + 4);
            }

            // Chart title
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(dataset.label, canvas.width / 2, 30);

            // Update chart info
            chartInfo.innerHTML = `
                <strong>Chart Type:</strong> ${chartType.toUpperCase()} |
                <strong>Data Points:</strong> ${data.length} |
                <strong>Range:</strong> ${minValue.toFixed(1)} - ${maxValue.toFixed(1)} |
                <strong>Max Value:</strong> ${maxValue} |
                <strong>Min Value:</strong> ${minValue}
            `;

            console.log(`${chartType} chart rendered successfully!`);
        }

        function renderLineChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange) {
            const canvas = document.getElementById('chartCanvas');
            ctx.strokeStyle = '#00d4ff';
            ctx.fillStyle = '#00d4ff';
            ctx.lineWidth = 3;

            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                const y = canvas.height - margin - ((data[i] - minValue) / valueRange) * chartHeight;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Draw data points
            for (let i = 0; i < data.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                const y = canvas.height - margin - ((data[i] - minValue) / valueRange) * chartHeight;

                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();

                // Add glow effect
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function renderBarChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange) {
            const barWidth = chartWidth / (labels.length * 2);
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];

            for (let i = 0; i < data.length; i++) {
                const x = margin + (chartWidth / labels.length) * i + barWidth / 2;
                const barHeight = ((data[i] - minValue) / valueRange) * chartHeight;
                const y = canvas.height - margin - barHeight;

                // Draw bar
                ctx.fillStyle = colors[i % colors.length];
                ctx.fillRect(x, y, barWidth, barHeight);

                // Draw bar border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth, barHeight);

                // Add value label on top
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(data[i].toString(), x + barWidth / 2, y - 5);
            }
        }

        function renderScatterChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange) {
            const canvas = document.getElementById('chartCanvas');
            const colors = ['#51cf66', '#ffd43b', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];

            for (let i = 0; i < data.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                const y = canvas.height - margin - ((data[i] - minValue) / valueRange) * chartHeight;

                // Draw circle with gradient
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
                gradient.addColorStop(0, colors[i % colors.length]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function renderAreaChartInternal(ctx, data, labels, margin, chartWidth, chartHeight, minValue, valueRange) {
            const canvas = document.getElementById('chartCanvas');
            // Create gradient for area fill
            const gradient = ctx.createLinearGradient(0, margin, 0, canvas.height - margin);
            gradient.addColorStop(0, 'rgba(255, 211, 59, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 211, 59, 0.1)');

            // Draw area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(margin, canvas.height - margin);

            for (let i = 0; i < data.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                const y = canvas.height - margin - ((data[i] - minValue) / valueRange) * chartHeight;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(canvas.width - margin, canvas.height - margin);
            ctx.closePath();
            ctx.fill();

            // Draw line on top
            ctx.strokeStyle = '#ffd43b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const x = margin + (chartWidth / (labels.length - 1)) * i;
                const y = canvas.height - margin - ((data[i] - minValue) / valueRange) * chartHeight;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function renderLineChart() {
            const chartData = {
                type: "line",
                data: {
                    labels: ["Q1", "Q2", "Q3", "Q4", "Q5", "Q6"],
                    datasets: [{
                        label: "Revenue Growth",
                        data: [45, 67, 89, 123, 156, 198]
                    }]
                }
            };
            renderChart(chartData, 'line');
            resultsDiv.innerHTML = `<div class="status success">üìà Line Chart Rendered!</div>`;
        }

        function renderBarChart() {
            const chartData = {
                type: "bar",
                data: {
                    labels: ["Sales", "Marketing", "Development", "Support", "Admin"],
                    datasets: [{
                        label: "Department Budget",
                        data: [120, 85, 200, 75, 60]
                    }]
                }
            };
            renderChart(chartData, 'bar');
            resultsDiv.innerHTML = `<div class="status success">üìä Bar Chart Rendered!</div>`;
        }

        function renderScatterChart() {
            const chartData = {
                type: "scatter",
                data: {
                    labels: ["A", "B", "C", "D", "E", "F"],
                    datasets: [{
                        label: "Performance Metrics",
                        data: [23, 45, 67, 89, 34, 78]
                    }]
                }
            };
            renderChart(chartData, 'scatter');
            resultsDiv.innerHTML = `<div class="status success">üîµ Scatter Plot Rendered!</div>`;
        }

        function renderAreaChart() {
            const chartData = {
                type: "area",
                data: {
                    labels: ["Jan", "Feb", "Mar", "Apr", "May", "Jun"],
                    datasets: [{
                        label: "User Engagement",
                        data: [12, 19, 3, 5, 2, 3]
                    }]
                }
            };
            renderChart(chartData, 'area');
            resultsDiv.innerHTML = `<div class="status success">üìà Area Chart Rendered!</div>`;
        }

        function testWebGPU() {
            if (!wasmModule) {
                resultsDiv.innerHTML = '<div class="status error">WASM module not loaded</div>';
                return;
            }

            try {
                const result = test_webgpu_support();
                console.log('WebGPU test result:', result);
                const isSupported = result === 'Supported';
                const className = isSupported ? 'success' : 'error';
                resultsDiv.innerHTML = `<div class="status ${className}">WebGPU Test: ${result}</div>`;
            } catch (error) {
                console.error('WebGPU test error:', error);
                resultsDiv.innerHTML = `<div class="status error">WebGPU test error: ${error.message}</div>`;
            }
        };

        // Initialize the WASM module when the page loads
        initializeWasm();

        // Expose functions to global scope for onclick handlers
        window.testGreet = testGreet;
        window.testDataProcessing = testDataProcessing;
        window.testChartCreation = testChartCreation;
        window.testWebGPU = testWebGPU;
    </script>
</body>
</html>
