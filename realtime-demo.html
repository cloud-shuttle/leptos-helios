<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helios Real-Time Data Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'bounce-slow': 'bounce 2s infinite',
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom animations and effects */
        .glass-effect {
            backdrop-filter: blur(16px) saturate(180%);
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .gradient-text {
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .pulse-ring {
            animation: pulse-ring 2s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(0.33);
            }
            40%, 50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(1.2);
            }
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 text-white overflow-x-hidden">
    <div class="max-w-7xl mx-auto px-4 py-8">
        <div class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold mb-4 gradient-text drop-shadow-lg">
                üöÄ Helios Real-Time Data Visualization
            </h1>
            <p class="text-xl text-gray-300">
                Live streaming data with multiple chart types and WebSocket integration
            </p>
        </div>

        <div class="glass-effect rounded-2xl p-6 mb-8 shadow-2xl">
            <div class="flex flex-wrap gap-4 items-center mb-4">
                <label class="font-semibold min-w-[120px]">Data Source:</label>
                <select id="dataSource" class="bg-white/20 backdrop-blur-sm border border-white/30 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white/30 transition-all duration-200">
                    <option value="stock" class="bg-gray-800">üìà Stock Prices</option>
                    <option value="sensor" class="bg-gray-800">üå°Ô∏è IoT Sensors</option>
                    <option value="network" class="bg-gray-800">üåê Network Traffic</option>
                    <option value="crypto" class="bg-gray-800">‚Çø Cryptocurrency</option>
                    <option value="weather" class="bg-gray-800">üå§Ô∏è Weather Data</option>
                </select>

                <label class="font-semibold min-w-[120px]">Update Frequency:</label>
                <select id="frequency" class="bg-white/20 backdrop-blur-sm border border-white/30 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white/30 transition-all duration-200">
                    <option value="100" class="bg-gray-800">100ms (Fast)</option>
                    <option value="250" class="bg-gray-800">250ms</option>
                    <option value="500" selected class="bg-gray-800">500ms (Default)</option>
                    <option value="1000" class="bg-gray-800">1s</option>
                    <option value="2000" class="bg-gray-800">2s (Slow)</option>
                </select>
            </div>

            <div class="flex flex-wrap gap-4 items-center mb-4">
                <label class="font-semibold min-w-[120px]">Max Data Points:</label>
                <input type="range" id="maxPoints" min="50" max="500" value="200" class="w-32 accent-blue-500">
                <span id="maxPointsValue" class="font-mono text-blue-300">200</span>

                <button id="startBtn" class="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white px-6 py-2 rounded-lg font-semibold transition-all duration-200 transform hover:scale-105 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    ‚ñ∂Ô∏è Start Streaming
                </button>
                <button id="stopBtn" disabled class="bg-gradient-to-r from-red-500 to-rose-600 hover:from-red-600 hover:to-rose-700 text-white px-6 py-2 rounded-lg font-semibold transition-all duration-200 transform hover:scale-105 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    ‚èπÔ∏è Stop Streaming
                </button>
                <button id="clearBtn" class="bg-gradient-to-r from-yellow-500 to-orange-600 hover:from-yellow-600 hover:to-orange-700 text-white px-6 py-2 rounded-lg font-semibold transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    üóëÔ∏è Clear Data
                </button>
            </div>

            <div class="flex flex-wrap gap-4 items-center">
                <label class="font-semibold min-w-[120px]">Connection:</label>
                <span id="connectionStatus" class="inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-red-500 text-white">
                    <span class="w-2 h-2 bg-white rounded-full mr-2"></span>
                    Disconnected
                </span>
                <label class="font-semibold min-w-[120px]">Streaming:</label>
                <span id="streamingStatus" class="inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-red-500 text-white">
                    <span class="w-2 h-2 bg-white rounded-full mr-2"></span>
                    Stopped
                </span>
            </div>
        </div>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
            <div class="glass-effect rounded-xl p-4 text-center shadow-lg">
                <div class="text-3xl font-bold text-blue-400 mb-2" id="dataPointsPerSecond">0</div>
                <div class="text-sm text-gray-300">Data Points/sec</div>
            </div>
            <div class="glass-effect rounded-xl p-4 text-center shadow-lg">
                <div class="text-3xl font-bold text-green-400 mb-2" id="totalDataPoints">0</div>
                <div class="text-sm text-gray-300">Total Points</div>
            </div>
            <div class="glass-effect rounded-xl p-4 text-center shadow-lg">
                <div class="text-3xl font-bold text-yellow-400 mb-2" id="renderTime">0ms</div>
                <div class="text-sm text-gray-300">Render Time</div>
            </div>
            <div class="glass-effect rounded-xl p-4 text-center shadow-lg">
                <div class="text-3xl font-bold text-purple-400 mb-2" id="uptime">00:00</div>
                <div class="text-sm text-gray-300">Uptime</div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <div class="glass-effect rounded-xl p-6 shadow-xl">
                <div class="text-xl font-semibold text-center mb-4 text-blue-300">üìà Line Chart</div>
                <canvas id="lineChart" width="600" height="300" class="w-full h-64 md:h-80 bg-black/20 rounded-lg border border-white/10"></canvas>
            </div>

            <div class="glass-effect rounded-xl p-6 shadow-xl">
                <div class="text-xl font-semibold text-center mb-4 text-green-300">üìä Bar Chart</div>
                <canvas id="barChart" width="600" height="300" class="w-full h-64 md:h-80 bg-black/20 rounded-lg border border-white/10"></canvas>
            </div>

            <div class="glass-effect rounded-xl p-6 shadow-xl">
                <div class="text-xl font-semibold text-center mb-4 text-yellow-300">üîµ Scatter Plot</div>
                <canvas id="scatterChart" width="600" height="300" class="w-full h-64 md:h-80 bg-black/20 rounded-lg border border-white/10"></canvas>
            </div>

            <div class="glass-effect rounded-xl p-6 shadow-xl">
                <div class="text-xl font-semibold text-center mb-4 text-purple-300">üìà Area Chart</div>
                <canvas id="areaChart" width="600" height="300" class="w-full h-64 md:h-80 bg-black/20 rounded-lg border border-white/10"></canvas>
            </div>
        </div>

        <div class="glass-effect rounded-xl p-4 shadow-xl">
            <div class="text-lg font-semibold mb-3 text-gray-200">üìã Console Output</div>
            <div id="console" class="bg-black/30 rounded-lg p-4 font-mono text-sm max-h-48 overflow-y-auto border border-white/10">
                <div class="text-blue-400 mb-1">[INFO] Real-time visualization demo initialized</div>
                <div class="text-blue-400 mb-1">[INFO] Ready to start streaming data...</div>
            </div>
        </div>
    </div>

    <script>
        class RealtimeVisualization {
            constructor() {
                this.websocket = null;
                this.isStreaming = false;
                this.data = [];
                this.maxPoints = 200;
                this.startTime = null;
                this.dataPointsPerSecond = 0;
                this.totalDataPoints = 0;
                this.lastSecond = 0;
                this.pointsThisSecond = 0;

                this.canvases = {
                    line: document.getElementById('lineChart'),
                    bar: document.getElementById('barChart'),
                    scatter: document.getElementById('scatterChart'),
                    area: document.getElementById('areaChart')
                };

                this.ctxs = {};
                for (const [type, canvas] of Object.entries(this.canvases)) {
                    this.ctxs[type] = canvas.getContext('2d');
                }

                this.initializeEventListeners();
                this.log('info', 'Real-time visualization system initialized');
            }

            initializeEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.startStreaming());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopStreaming());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearData());

                document.getElementById('maxPoints').addEventListener('input', (e) => {
                    this.maxPoints = parseInt(e.target.value);
                    document.getElementById('maxPointsValue').textContent = this.maxPoints;
                });

                document.getElementById('dataSource').addEventListener('change', () => {
                    if (this.isStreaming) {
                        this.stopStreaming();
                        setTimeout(() => this.startStreaming(), 100);
                    }
                });
            }

            log(type, message) {
                const console = document.getElementById('console');
                const timestamp = new Date().toLocaleTimeString();
                const line = document.createElement('div');

                let colorClass = 'text-gray-400';
                switch (type) {
                    case 'info': colorClass = 'text-blue-400'; break;
                    case 'success': colorClass = 'text-green-400'; break;
                    case 'warning': colorClass = 'text-yellow-400'; break;
                    case 'error': colorClass = 'text-red-400'; break;
                }

                line.className = `${colorClass} mb-1`;
                line.textContent = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
                console.appendChild(line);
                console.scrollTop = console.scrollHeight;

                // Keep only last 50 lines
                while (console.children.length > 50) {
                    console.removeChild(console.firstChild);
                }
            }

            async startStreaming() {
                if (this.isStreaming) return;

                this.isStreaming = true;
                this.startTime = Date.now();
                this.dataPointsPerSecond = 0;
                this.totalDataPoints = 0;
                this.pointsThisSecond = 0;
                this.lastSecond = Math.floor(Date.now() / 1000);

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('streamingStatus').innerHTML = '<span class="w-2 h-2 bg-white rounded-full mr-2 animate-pulse"></span>Streaming';
                document.getElementById('streamingStatus').className = 'inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-yellow-500 text-white';

                this.log('success', 'Starting data streaming...');

                // Try WebSocket connection first, fallback to local generation
                try {
                    await this.connectWebSocket();
                } catch (error) {
                    this.log('warning', 'WebSocket connection failed, using local data generation');
                    this.startLocalGeneration();
                }
            }

            async connectWebSocket() {
                const wsPort = 8083;
                const wsUrl = `ws://localhost:${wsPort}`;

                return new Promise((resolve, reject) => {
                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                    this.log('success', `Connected to WebSocket server on port ${wsPort}`);
                    document.getElementById('connectionStatus').innerHTML = '<span class="w-2 h-2 bg-white rounded-full mr-2"></span>Connected';
                    document.getElementById('connectionStatus').className = 'inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-green-500 text-white';

                        // Subscribe to data stream
                        const dataSource = document.getElementById('dataSource').value;
                        const frequency = parseInt(document.getElementById('frequency').value);

                        this.websocket.send(JSON.stringify({
                            type: 'subscribe',
                            source: dataSource,
                            frequency: frequency
                        }));

                        resolve();
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            if (message.type === 'data') {
                                this.addDataPoint(message.data);
                            }
                        } catch (error) {
                            this.log('error', `Failed to parse WebSocket message: ${error.message}`);
                        }
                    };

                    this.websocket.onclose = () => {
                        this.log('warning', 'WebSocket connection closed');
                        document.getElementById('connectionStatus').innerHTML = '<span class="w-2 h-2 bg-white rounded-full mr-2"></span>Disconnected';
                        document.getElementById('connectionStatus').className = 'inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-red-500 text-white';

                        if (this.isStreaming) {
                            this.log('info', 'Falling back to local data generation');
                            this.startLocalGeneration();
                        }
                    };

                    this.websocket.onerror = (error) => {
                        this.log('error', `WebSocket error: ${error.message || 'Connection failed'}`);
                        reject(error);
                    };

                    // Timeout after 3 seconds
                    setTimeout(() => {
                        if (this.websocket.readyState !== WebSocket.OPEN) {
                            reject(new Error('WebSocket connection timeout'));
                        }
                    }, 3000);
                });
            }

            startLocalGeneration() {
                this.log('info', 'Starting local data generation');
                document.getElementById('connectionStatus').innerHTML = '<span class="w-2 h-2 bg-white rounded-full mr-2 animate-pulse"></span>Local Mode';
                document.getElementById('connectionStatus').className = 'inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-yellow-500 text-white';

                const dataSource = document.getElementById('dataSource').value;
                const frequency = parseInt(document.getElementById('frequency').value);

                this.generationInterval = setInterval(() => {
                    const dataPoint = this.generateDataPoint(dataSource);
                    this.addDataPoint(dataPoint);
                }, frequency);
            }

            generateDataPoint(sourceType) {
                const now = Date.now();
                const baseTime = now / 1000;

                switch (sourceType) {
                    case 'stock':
                        return {
                            timestamp: now,
                            price: 100 + Math.sin(baseTime * 0.1) * 20 + Math.random() * 10 - 5,
                            volume: 1000000 + Math.random() * 500000,
                            market_cap: 1000000000 + Math.random() * 100000000
                        };
                    case 'sensor':
                        return {
                            timestamp: now,
                            temperature: 20 + Math.sin(baseTime * 0.05) * 10 + Math.random() * 4 - 2,
                            humidity: 50 + Math.sin(baseTime * 0.03) * 20 + Math.random() * 10 - 5,
                            pressure: 1013.25 + Math.sin(baseTime * 0.02) * 50 + Math.random() * 20 - 10,
                            light: Math.max(0, 500 + Math.sin(baseTime * 0.1) * 300 + Math.random() * 100 - 50)
                        };
                    case 'network':
                        return {
                            timestamp: now,
                            bandwidth: 500 + Math.sin(baseTime * 0.08) * 200 + Math.random() * 100 - 50,
                            latency: 20 + Math.sin(baseTime * 0.06) * 15 + Math.random() * 10 - 5,
                            packets: 5000 + Math.sin(baseTime * 0.04) * 2000 + Math.random() * 1000 - 500,
                            errors: Math.max(0, 2 + Math.sin(baseTime * 0.1) * 3 + Math.random() * 2 - 1)
                        };
                    case 'crypto':
                        return {
                            timestamp: now,
                            price: 50000 + Math.sin(baseTime * 0.12) * 10000 + Math.random() * 5000 - 2500,
                            volume: 1000000 + Math.sin(baseTime * 0.07) * 500000 + Math.random() * 200000 - 100000,
                            market_cap: 1000000000000 + Math.sin(baseTime * 0.05) * 200000000000 + Math.random() * 100000000000 - 50000000000,
                            dominance: 40 + Math.sin(baseTime * 0.03) * 10 + Math.random() * 5 - 2.5
                        };
                    case 'weather':
                        return {
                            timestamp: now,
                            temperature: 15 + Math.sin(baseTime * 0.02) * 15 + Math.random() * 6 - 3,
                            humidity: 60 + Math.sin(baseTime * 0.04) * 20 + Math.random() * 10 - 5,
                            wind_speed: 10 + Math.sin(baseTime * 0.06) * 8 + Math.random() * 4 - 2,
                            pressure: 1013.25 + Math.sin(baseTime * 0.01) * 30 + Math.random() * 10 - 5,
                            precipitation: Math.max(0, Math.sin(baseTime * 0.05) * 5 + Math.random() * 2 - 1)
                        };
                    default:
                        return {
                            timestamp: now,
                            value: Math.sin(baseTime * 0.1) * 100 + Math.random() * 50 - 25
                        };
                }
            }

            addDataPoint(dataPoint) {
                this.data.push(dataPoint);

                // Limit data points
                if (this.data.length > this.maxPoints) {
                    this.data.shift();
                }

                this.totalDataPoints++;
                this.pointsThisSecond++;

                // Update metrics
                this.updateMetrics();

                // Render charts
                this.renderAllCharts();
            }

            updateMetrics() {
                const now = Math.floor(Date.now() / 1000);
                if (now > this.lastSecond) {
                    this.dataPointsPerSecond = this.pointsThisSecond;
                    this.pointsThisSecond = 0;
                    this.lastSecond = now;

                    document.getElementById('dataPointsPerSecond').textContent = this.dataPointsPerSecond;
                }

                document.getElementById('totalDataPoints').textContent = this.totalDataPoints;

                if (this.startTime) {
                    const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(uptime / 60);
                    const seconds = uptime % 60;
                    document.getElementById('uptime').textContent =
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }

            renderAllCharts() {
                const startTime = performance.now();

                this.renderLineChart();
                this.renderBarChart();
                this.renderScatterChart();
                this.renderAreaChart();

                const renderTime = Math.round(performance.now() - startTime);
                document.getElementById('renderTime').textContent = `${renderTime}ms`;
            }

            renderLineChart() {
                const ctx = this.ctxs.line;
                const canvas = this.canvases.line;
                this.clearCanvas(ctx, canvas);

                if (this.data.length < 2) return;

                const margin = 40;
                const width = canvas.width - 2 * margin;
                const height = canvas.height - 2 * margin;

                // Get data values
                const values = this.data.map(d => this.getPrimaryValue(d));
                const minVal = Math.min(...values);
                const maxVal = Math.max(...values);
                const range = maxVal - minVal || 1;

                // Draw grid
                this.drawGrid(ctx, margin, width, height);

                // Draw line
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < this.data.length; i++) {
                    const x = margin + (width / (this.data.length - 1)) * i;
                    const y = margin + height - ((values[i] - minVal) / range) * height;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw data points
                ctx.fillStyle = '#00d4ff';
                for (let i = 0; i < this.data.length; i++) {
                    const x = margin + (width / (this.data.length - 1)) * i;
                    const y = margin + height - ((values[i] - minVal) / range) * height;

                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            renderBarChart() {
                const ctx = this.ctxs.bar;
                const canvas = this.canvases.bar;
                this.clearCanvas(ctx, canvas);

                if (this.data.length === 0) return;

                const margin = 40;
                const width = canvas.width - 2 * margin;
                const height = canvas.height - 2 * margin;

                // Get recent data (last 10 points)
                const recentData = this.data.slice(-10);
                const values = recentData.map(d => this.getPrimaryValue(d));
                const minVal = Math.min(...values);
                const maxVal = Math.max(...values);
                const range = maxVal - minVal || 1;

                // Draw grid
                this.drawGrid(ctx, margin, width, height);

                // Draw bars
                const barWidth = width / recentData.length * 0.8;
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#a8e6cf', '#ffd3a5', '#fd79a8', '#6c5ce7'];

                for (let i = 0; i < recentData.length; i++) {
                    const x = margin + (width / recentData.length) * i + (width / recentData.length - barWidth) / 2;
                    const barHeight = ((values[i] - minVal) / range) * height;
                    const y = margin + height - barHeight;

                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fillRect(x, y, barWidth, barHeight);

                    // Draw value label
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.round(values[i]).toString(), x + barWidth / 2, y - 5);
                }
            }

            renderScatterChart() {
                const ctx = this.ctxs.scatter;
                const canvas = this.canvases.scatter;
                this.clearCanvas(ctx, canvas);

                if (this.data.length === 0) return;

                const margin = 40;
                const width = canvas.width - 2 * margin;
                const height = canvas.height - 2 * margin;

                // Get data values
                const values = this.data.map(d => this.getPrimaryValue(d));
                const minVal = Math.min(...values);
                const maxVal = Math.max(...values);
                const range = maxVal - minVal || 1;

                // Draw grid
                this.drawGrid(ctx, margin, width, height);

                // Draw scatter points
                const colors = ['#51cf66', '#ffd43b', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];

                for (let i = 0; i < this.data.length; i++) {
                    const x = margin + (width / (this.data.length - 1)) * i;
                    const y = margin + height - ((values[i] - minVal) / range) * height;

                    // Create gradient
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
                    gradient.addColorStop(0, colors[i % colors.length]);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fill();

                    // Draw border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            renderAreaChart() {
                const ctx = this.ctxs.area;
                const canvas = this.canvases.area;
                this.clearCanvas(ctx, canvas);

                if (this.data.length < 2) return;

                const margin = 40;
                const width = canvas.width - 2 * margin;
                const height = canvas.height - 2 * margin;

                // Get data values
                const values = this.data.map(d => this.getPrimaryValue(d));
                const minVal = Math.min(...values);
                const maxVal = Math.max(...values);
                const range = maxVal - minVal || 1;

                // Draw grid
                this.drawGrid(ctx, margin, width, height);

                // Create gradient for area fill
                const gradient = ctx.createLinearGradient(0, margin, 0, margin + height);
                gradient.addColorStop(0, 'rgba(255, 211, 59, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 211, 59, 0.1)');

                // Draw area
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(margin, margin + height);

                for (let i = 0; i < this.data.length; i++) {
                    const x = margin + (width / (this.data.length - 1)) * i;
                    const y = margin + height - ((values[i] - minVal) / range) * height;
                    ctx.lineTo(x, y);
                }

                ctx.lineTo(margin + width, margin + height);
                ctx.closePath();
                ctx.fill();

                // Draw line on top
                ctx.strokeStyle = '#ffd43b';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < this.data.length; i++) {
                    const x = margin + (width / (this.data.length - 1)) * i;
                    const y = margin + height - ((values[i] - minVal) / range) * height;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            getPrimaryValue(dataPoint) {
                const dataSource = document.getElementById('dataSource').value;

                switch (dataSource) {
                    case 'stock': return dataPoint.price || 0;
                    case 'sensor': return dataPoint.temperature || 0;
                    case 'network': return dataPoint.bandwidth || 0;
                    case 'crypto': return dataPoint.price || 0;
                    case 'weather': return dataPoint.temperature || 0;
                    default: return dataPoint.value || 0;
                }
            }

            drawGrid(ctx, margin, width, height) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);

                // Horizontal grid lines
                for (let i = 0; i <= 5; i++) {
                    const y = margin + (height / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(margin, y);
                    ctx.lineTo(margin + width, y);
                    ctx.stroke();
                }

                // Vertical grid lines
                for (let i = 0; i <= 10; i++) {
                    const x = margin + (width / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(x, margin);
                    ctx.lineTo(x, margin + height);
                    ctx.stroke();
                }

                ctx.setLineDash([]);
            }

            clearCanvas(ctx, canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            stopStreaming() {
                this.isStreaming = false;

                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }

                if (this.generationInterval) {
                    clearInterval(this.generationInterval);
                    this.generationInterval = null;
                }

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('streamingStatus').innerHTML = '<span class="w-2 h-2 bg-white rounded-full mr-2"></span>Stopped';
                document.getElementById('streamingStatus').className = 'inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold bg-red-500 text-white';

                this.log('info', 'Data streaming stopped');
            }

            clearData() {
                this.data = [];
                this.totalDataPoints = 0;
                this.dataPointsPerSecond = 0;

                // Clear all canvases
                for (const ctx of Object.values(this.ctxs)) {
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                }

                // Reset metrics
                document.getElementById('totalDataPoints').textContent = '0';
                document.getElementById('dataPointsPerSecond').textContent = '0';
                document.getElementById('renderTime').textContent = '0ms';
                document.getElementById('uptime').textContent = '00:00';

                this.log('info', 'Data cleared');
            }
        }

        // Initialize the application
        const app = new RealtimeVisualization();
    </script>
</body>
</html>
