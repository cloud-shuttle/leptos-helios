<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helios Live Streaming Visualization Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: white;
            font-size: 2rem;
            font-weight: 300;
            text-align: center;
        }

        .header p {
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            margin-top: 0.5rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .control-group select,
        .control-group input {
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.9rem;
        }

        .control-group select option {
            background: #2a5298;
            color: white;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .btn-success {
            background: linear-gradient(45deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(46, 204, 113, 0.4);
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 2rem;
            max-width: 1600px;
            margin: 0 auto;
        }

        .chart-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .chart-panel h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .chart-canvas {
            width: 100%;
            height: 300px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: white;
        }

        .metrics-panel {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .metric-card h4 {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 0.5rem;
        }

        .metric-card .value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-connected {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }

        .status-disconnected {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .log-container {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem;
            border-radius: 4px;
        }

        .log-info {
            color: #00ff00;
        }

        .log-warning {
            color: #ffaa00;
        }

        .log-error {
            color: #ff4444;
        }

        .log-success {
            color: #44ff44;
        }

        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
                padding: 1rem;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .header h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ Helios Live Streaming Visualization</h1>
        <p>Real-time data visualization with advanced charting capabilities</p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="data-source">Data Source</label>
            <select id="data-source">
                <option value="stock">Stock Prices</option>
                <option value="sensor">IoT Sensors</option>
                <option value="network">Network Traffic</option>
                <option value="crypto">Cryptocurrency</option>
                <option value="weather">Weather Data</option>
                <option value="social">Social Network</option>
                <option value="infrastructure">Infrastructure Graph</option>
                <option value="knowledge">Knowledge Graph</option>
            </select>
        </div>

        <div class="control-group">
            <label for="update-frequency">Update Frequency</label>
            <select id="update-frequency">
                <option value="100">100ms (Fast)</option>
                <option value="500" selected>500ms (Normal)</option>
                <option value="1000">1s (Slow)</option>
                <option value="2000">2s (Very Slow)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="data-points">Data Points</label>
            <input type="range" id="data-points" min="50" max="500" value="100">
            <span id="data-points-value">100</span>
        </div>

        <div class="control-group">
            <label>&nbsp;</label>
            <button id="start-streaming" class="btn btn-success">Start Streaming</button>
        </div>

        <div class="control-group">
            <label>&nbsp;</label>
            <button id="stop-streaming" class="btn btn-danger">Stop Streaming</button>
        </div>
    </div>

    <div class="charts-container">
        <div class="chart-panel">
            <h3>üìà Real-time Line Chart</h3>
            <canvas id="line-chart" class="chart-canvas"></canvas>
        </div>

        <div class="chart-panel">
            <h3>üìä Real-time Bar Chart</h3>
            <canvas id="bar-chart" class="chart-canvas"></canvas>
        </div>

        <div class="chart-panel">
            <h3>üîµ Real-time Scatter Plot</h3>
            <canvas id="scatter-chart" class="chart-canvas"></canvas>
        </div>

        <div class="chart-panel">
            <h3>üåä Real-time Area Chart</h3>
            <canvas id="area-chart" class="chart-canvas"></canvas>
        </div>

        <div class="chart-panel">
            <h3>üï∏Ô∏è Network Graph</h3>
            <canvas id="graph-chart" class="chart-canvas"></canvas>
        </div>

        <div class="chart-panel">
            <h3>üåê Force-Directed Layout</h3>
            <canvas id="force-chart" class="chart-canvas"></canvas>
        </div>

        <div class="metrics-panel">
            <h3>üìä Live Performance Metrics</h3>
            <div class="metrics-grid">
                <div class="metric-card">
                    <h4>Streaming Status</h4>
                    <div class="value">
                        <span id="connection-status" class="status-indicator status-disconnected"></span>
                        <span id="connection-text">Stopped</span>
                    </div>
                </div>
                <div class="metric-card">
                    <h4>Data Points/sec</h4>
                    <div class="value" id="data-rate">0</div>
                </div>
                <div class="metric-card">
                    <h4>Render Time</h4>
                    <div class="value" id="render-time">0ms</div>
                </div>
                <div class="metric-card">
                    <h4>Memory Usage</h4>
                    <div class="value" id="memory-usage">0MB</div>
                </div>
                <div class="metric-card">
                    <h4>Total Points</h4>
                    <div class="value" id="total-points">0</div>
                </div>
                <div class="metric-card">
                    <h4>Uptime</h4>
                    <div class="value" id="uptime">00:00:00</div>
                </div>
            </div>

            <div class="log-container" id="log-container">
                <div class="log-entry log-info">üöÄ Helios Live Streaming Demo initialized</div>
                <div class="log-entry log-info">üìä Ready to start data streaming</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let isStreaming = false;
        let streamingInterval = null;
        let startTime = null;
        let dataPoints = [];
        let maxDataPoints = 100;
        let updateFrequency = 500;
        let dataSource = 'stock';
        let renderTimes = [];
        let dataRate = 0;
        let lastDataTime = Date.now();

        // Chart canvases
        const lineChart = document.getElementById('line-chart');
        const barChart = document.getElementById('bar-chart');
        const scatterChart = document.getElementById('scatter-chart');
        const areaChart = document.getElementById('area-chart');
        const graphChart = document.getElementById('graph-chart');
        const forceChart = document.getElementById('force-chart');

        // Setup canvases
        function setupCanvas(canvas) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            return ctx;
        }

        // Initialize all canvases
        const lineCtx = setupCanvas(lineChart);
        const barCtx = setupCanvas(barChart);
        const scatterCtx = setupCanvas(scatterChart);
        const areaCtx = setupCanvas(areaChart);
        const graphCtx = setupCanvas(graphChart);
        const forceCtx = setupCanvas(forceChart);

        // Data generation functions
        function generateStockData() {
            const basePrice = 100 + Math.random() * 50;
            const volatility = 0.02;
            const trend = (Math.random() - 0.5) * 0.001;
            return {
                price: basePrice * (1 + (Math.random() - 0.5) * volatility + trend),
                volume: Math.random() * 1000000,
                timestamp: Date.now()
            };
        }

        function generateSensorData() {
            return {
                temperature: 20 + Math.random() * 15,
                humidity: 40 + Math.random() * 40,
                pressure: 1000 + Math.random() * 50,
                timestamp: Date.now()
            };
        }

        function generateNetworkData() {
            return {
                bandwidth: Math.random() * 1000,
                latency: 10 + Math.random() * 50,
                packets: Math.random() * 10000,
                timestamp: Date.now()
            };
        }

        function generateCryptoData() {
            const basePrice = 50000 + Math.random() * 20000;
            return {
                price: basePrice * (1 + (Math.random() - 0.5) * 0.05),
                volume: Math.random() * 1000000000,
                marketCap: basePrice * (1000000 + Math.random() * 500000),
                timestamp: Date.now()
            };
        }

        function generateWeatherData() {
            return {
                temperature: 15 + Math.random() * 20,
                humidity: 30 + Math.random() * 50,
                windSpeed: Math.random() * 30,
                pressure: 980 + Math.random() * 40,
                timestamp: Date.now()
            };
        }

        function generateSocialNetworkData() {
            const nodes = [];
            const edges = [];
            const nodeCount = 15 + Math.floor(Math.random() * 10);

            // Generate nodes (people)
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    id: i,
                    x: Math.random() * 400 + 50,
                    y: Math.random() * 300 + 50,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: 5 + Math.random() * 10,
                    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                    label: `User${i}`,
                    connections: 0
                });
            }

            // Generate edges (connections)
            for (let i = 0; i < nodeCount; i++) {
                const connectionCount = Math.floor(Math.random() * 5) + 1;
                for (let j = 0; j < connectionCount; j++) {
                    const target = Math.floor(Math.random() * nodeCount);
                    if (target !== i && !edges.some(e =>
                        (e.source === i && e.target === target) ||
                        (e.source === target && e.target === i)
                    )) {
                        edges.push({
                            source: i,
                            target: target,
                            weight: Math.random() * 5 + 1,
                            color: `rgba(102, 126, 234, ${0.3 + Math.random() * 0.4})`
                        });
                        nodes[i].connections++;
                        nodes[target].connections++;
                    }
                }
            }

            return {
                nodes,
                edges,
                timestamp: Date.now(),
                type: 'social_network'
            };
        }

        function generateInfrastructureData() {
            const nodes = [];
            const edges = [];
            const nodeTypes = ['server', 'router', 'switch', 'database', 'cache'];

            // Generate infrastructure nodes
            for (let i = 0; i < 20; i++) {
                const type = nodeTypes[Math.floor(Math.random() * nodeTypes.length)];
                nodes.push({
                    id: i,
                    x: Math.random() * 400 + 50,
                    y: Math.random() * 300 + 50,
                    vx: (Math.random() - 0.5) * 1,
                    vy: (Math.random() - 0.5) * 1,
                    size: type === 'server' ? 12 : type === 'database' ? 10 : 8,
                    color: type === 'server' ? '#e74c3c' :
                           type === 'database' ? '#3498db' :
                           type === 'router' ? '#f39c12' : '#2ecc71',
                    label: `${type.toUpperCase()}${i}`,
                    type: type,
                    load: Math.random() * 100,
                    status: Math.random() > 0.1 ? 'online' : 'offline'
                });
            }

            // Generate network connections
            for (let i = 0; i < nodes.length; i++) {
                const connectionCount = Math.floor(Math.random() * 3) + 1;
                for (let j = 0; j < connectionCount; j++) {
                    const target = Math.floor(Math.random() * nodes.length);
                    if (target !== i && !edges.some(e =>
                        (e.source === i && e.target === target) ||
                        (e.source === target && e.target === i)
                    )) {
                        edges.push({
                            source: i,
                            target: target,
                            bandwidth: Math.random() * 1000 + 100,
                            latency: Math.random() * 50 + 1,
                            color: `rgba(52, 152, 219, ${0.4 + Math.random() * 0.4})`
                        });
                    }
                }
            }

            return {
                nodes,
                edges,
                timestamp: Date.now(),
                type: 'infrastructure'
            };
        }

        function generateKnowledgeGraphData() {
            const nodes = [];
            const edges = [];
            const concepts = ['AI', 'Machine Learning', 'Data Science', 'Neural Networks',
                            'Deep Learning', 'Computer Vision', 'NLP', 'Robotics',
                            'Blockchain', 'Cryptocurrency', 'Web3', 'DeFi', 'NFT',
                            'Cloud Computing', 'Microservices', 'DevOps', 'Kubernetes'];

            // Generate concept nodes
            for (let i = 0; i < concepts.length; i++) {
                nodes.push({
                    id: i,
                    x: Math.random() * 400 + 50,
                    y: Math.random() * 300 + 50,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: (Math.random() - 0.5) * 1.5,
                    size: 8 + Math.random() * 8,
                    color: `hsl(${(i * 20) % 360}, 70%, 50%)`,
                    label: concepts[i],
                    relevance: Math.random() * 100,
                    category: i < 8 ? 'AI/ML' : i < 13 ? 'Blockchain' : 'Infrastructure'
                });
            }

            // Generate semantic relationships
            for (let i = 0; i < nodes.length; i++) {
                const relationCount = Math.floor(Math.random() * 4) + 1;
                for (let j = 0; j < relationCount; j++) {
                    const target = Math.floor(Math.random() * nodes.length);
                    if (target !== i && !edges.some(e =>
                        (e.source === i && e.target === target) ||
                        (e.source === target && e.target === i)
                    )) {
                        const relations = ['related_to', 'part_of', 'influences', 'depends_on'];
                        edges.push({
                            source: i,
                            target: target,
                            relation: relations[Math.floor(Math.random() * relations.length)],
                            strength: Math.random() * 10 + 1,
                            color: `rgba(155, 89, 182, ${0.3 + Math.random() * 0.4})`
                        });
                    }
                }
            }

            return {
                nodes,
                edges,
                timestamp: Date.now(),
                type: 'knowledge_graph'
            };
        }

        function generateData() {
            switch (dataSource) {
                case 'stock': return generateStockData();
                case 'sensor': return generateSensorData();
                case 'network': return generateNetworkData();
                case 'crypto': return generateCryptoData();
                case 'weather': return generateWeatherData();
                case 'social': return generateSocialNetworkData();
                case 'infrastructure': return generateInfrastructureData();
                case 'knowledge': return generateKnowledgeGraphData();
                default: return generateStockData();
            }
        }

        // Chart rendering functions
        function renderLineChart() {
            const startTime = performance.now();
            const ctx = lineCtx;
            const canvas = lineChart;
            const rect = canvas.getBoundingClientRect();

            ctx.clearRect(0, 0, rect.width, rect.height);

            if (dataPoints.length < 2) return;

            // Get data values based on source
            let values = [];
            switch (dataSource) {
                case 'stock':
                    values = dataPoints.map(d => d.price);
                    break;
                case 'sensor':
                    values = dataPoints.map(d => d.temperature);
                    break;
                case 'network':
                    values = dataPoints.map(d => d.bandwidth);
                    break;
                case 'crypto':
                    values = dataPoints.map(d => d.price);
                    break;
                case 'weather':
                    values = dataPoints.map(d => d.temperature);
                    break;
            }

            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const valueRange = maxValue - minValue || 1;

            const padding = 40;
            const chartWidth = rect.width - padding * 2;
            const chartHeight = rect.height - padding * 2;

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const x = padding + (i / 5) * chartWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, rect.height - padding);
                ctx.stroke();
            }

            for (let i = 0; i <= 4; i++) {
                const y = padding + (i / 4) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(rect.width - padding, y);
                ctx.stroke();
            }

            // Draw line
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();

            dataPoints.forEach((point, index) => {
                const x = padding + (index / (dataPoints.length - 1)) * chartWidth;
                const normalizedY = (values[index] - minValue) / valueRange;
                const y = rect.height - padding - (normalizedY * chartHeight);

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Draw data points
            ctx.fillStyle = '#667eea';
            dataPoints.forEach((point, index) => {
                const x = padding + (index / (dataPoints.length - 1)) * chartWidth;
                const normalizedY = (values[index] - minValue) / valueRange;
                const y = rect.height - padding - (normalizedY * chartHeight);

                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw title
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Real-time Line Chart', rect.width / 2, 20);

            const renderTime = performance.now() - startTime;
            renderTimes.push(renderTime);
            if (renderTimes.length > 10) renderTimes.shift();
        }

        function renderBarChart() {
            const startTime = performance.now();
            const ctx = barCtx;
            const canvas = barChart;
            const rect = canvas.getBoundingClientRect();

            ctx.clearRect(0, 0, rect.width, rect.height);

            if (dataPoints.length === 0) return;

            // Get recent data points for bars
            const recentPoints = dataPoints.slice(-20);
            let values = [];
            switch (dataSource) {
                case 'stock':
                    values = recentPoints.map(d => d.volume / 10000);
                    break;
                case 'sensor':
                    values = recentPoints.map(d => d.humidity);
                    break;
                case 'network':
                    values = recentPoints.map(d => d.packets / 100);
                    break;
                case 'crypto':
                    values = recentPoints.map(d => d.volume / 1000000);
                    break;
                case 'weather':
                    values = recentPoints.map(d => d.humidity);
                    break;
            }

            const maxValue = Math.max(...values) || 1;
            const padding = 40;
            const chartWidth = rect.width - padding * 2;
            const chartHeight = rect.height - padding * 2;
            const barWidth = chartWidth / values.length;

            // Draw bars
            values.forEach((value, index) => {
                const barHeight = (value / maxValue) * chartHeight;
                const x = padding + index * barWidth;
                const y = rect.height - padding - barHeight;

                const gradient = ctx.createLinearGradient(0, y, 0, rect.height - padding);
                gradient.addColorStop(0, '#764ba2');
                gradient.addColorStop(1, '#667eea');

                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth - 2, barHeight);
            });

            // Draw title
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Real-time Bar Chart', rect.width / 2, 20);

            const renderTime = performance.now() - startTime;
            renderTimes.push(renderTime);
            if (renderTimes.length > 10) renderTimes.shift();
        }

        function renderScatterChart() {
            const startTime = performance.now();
            const ctx = scatterCtx;
            const canvas = scatterChart;
            const rect = canvas.getBoundingClientRect();

            ctx.clearRect(0, 0, rect.width, rect.height);

            if (dataPoints.length === 0) return;

            // Get recent data points
            const recentPoints = dataPoints.slice(-50);
            let xValues = [], yValues = [];

            switch (dataSource) {
                case 'stock':
                    xValues = recentPoints.map(d => d.price);
                    yValues = recentPoints.map(d => d.volume / 10000);
                    break;
                case 'sensor':
                    xValues = recentPoints.map(d => d.temperature);
                    yValues = recentPoints.map(d => d.humidity);
                    break;
                case 'network':
                    xValues = recentPoints.map(d => d.bandwidth);
                    yValues = recentPoints.map(d => d.latency);
                    break;
                case 'crypto':
                    xValues = recentPoints.map(d => d.price);
                    yValues = recentPoints.map(d => d.volume / 1000000);
                    break;
                case 'weather':
                    xValues = recentPoints.map(d => d.temperature);
                    yValues = recentPoints.map(d => d.windSpeed);
                    break;
            }

            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;

            const padding = 40;
            const chartWidth = rect.width - padding * 2;
            const chartHeight = rect.height - padding * 2;

            // Draw scatter points
            recentPoints.forEach((point, index) => {
                const x = padding + ((xValues[index] - minX) / rangeX) * chartWidth;
                const y = rect.height - padding - ((yValues[index] - minY) / rangeY) * chartHeight;

                const hue = (index / recentPoints.length) * 360;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw title
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Real-time Scatter Plot', rect.width / 2, 20);

            const renderTime = performance.now() - startTime;
            renderTimes.push(renderTime);
            if (renderTimes.length > 10) renderTimes.shift();
        }

        function renderAreaChart() {
            const startTime = performance.now();
            const ctx = areaCtx;
            const canvas = areaChart;
            const rect = canvas.getBoundingClientRect();

            ctx.clearRect(0, 0, rect.width, rect.height);

            if (dataPoints.length < 2) return;

            // Get data values
            let values = [];
            switch (dataSource) {
                case 'stock':
                    values = dataPoints.map(d => d.price);
                    break;
                case 'sensor':
                    values = dataPoints.map(d => d.pressure);
                    break;
                case 'network':
                    values = dataPoints.map(d => d.bandwidth);
                    break;
                case 'crypto':
                    values = dataPoints.map(d => d.marketCap / 1000000);
                    break;
                case 'weather':
                    values = dataPoints.map(d => d.pressure);
                    break;
            }

            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const valueRange = maxValue - minValue || 1;

            const padding = 40;
            const chartWidth = rect.width - padding * 2;
            const chartHeight = rect.height - padding * 2;

            // Draw area
            const gradient = ctx.createLinearGradient(0, padding, 0, rect.height - padding);
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.8)');
            gradient.addColorStop(1, 'rgba(118, 75, 162, 0.3)');

            ctx.fillStyle = gradient;
            ctx.beginPath();

            dataPoints.forEach((point, index) => {
                const x = padding + (index / (dataPoints.length - 1)) * chartWidth;
                const normalizedY = (values[index] - minValue) / valueRange;
                const y = rect.height - padding - (normalizedY * chartHeight);

                if (index === 0) {
                    ctx.moveTo(x, rect.height - padding);
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.lineTo(rect.width - padding, rect.height - padding);
            ctx.closePath();
            ctx.fill();

            // Draw line
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();

            dataPoints.forEach((point, index) => {
                const x = padding + (index / (dataPoints.length - 1)) * chartWidth;
                const normalizedY = (values[index] - minValue) / valueRange;
                const y = rect.height - padding - (normalizedY * chartHeight);

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Draw title
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Real-time Area Chart', rect.width / 2, 20);

            const renderTime = performance.now() - startTime;
            renderTimes.push(renderTime);
            if (renderTimes.length > 10) renderTimes.shift();
        }

        function renderGraphChart() {
            const startTime = performance.now();
            const ctx = graphCtx;
            const canvas = graphChart;
            const rect = canvas.getBoundingClientRect();

            ctx.clearRect(0, 0, rect.width, rect.height);

            if (dataPoints.length === 0) return;

            const latestData = dataPoints[dataPoints.length - 1];
            if (!latestData.nodes || !latestData.edges) return;

            const nodes = latestData.nodes;
            const edges = latestData.edges;

            // Draw edges first (so they appear behind nodes)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            edges.forEach(edge => {
                const sourceNode = nodes[edge.source];
                const targetNode = nodes[edge.target];
                if (sourceNode && targetNode) {
                    ctx.strokeStyle = edge.color || '#e0e0e0';
                    ctx.lineWidth = edge.weight ? edge.weight / 2 : 1;
                    ctx.beginPath();
                    ctx.moveTo(sourceNode.x, sourceNode.y);
                    ctx.lineTo(targetNode.x, targetNode.y);
                    ctx.stroke();
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                ctx.fillStyle = node.color || '#667eea';
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.size || 5, 0, 2 * Math.PI);
                ctx.fill();

                // Draw node label
                ctx.fillStyle = '#2c3e50';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(node.label || node.id, node.x, node.y - node.size - 5);
            });

            // Draw title
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Network Graph', rect.width / 2, 20);

            const renderTime = performance.now() - startTime;
            renderTimes.push(renderTime);
            if (renderTimes.length > 10) renderTimes.shift();
        }

        function renderForceChart() {
            const startTime = performance.now();
            const ctx = forceCtx;
            const canvas = forceChart;
            const rect = canvas.getBoundingClientRect();

            ctx.clearRect(0, 0, rect.width, rect.height);

            if (dataPoints.length === 0) return;

            const latestData = dataPoints[dataPoints.length - 1];
            if (!latestData.nodes || !latestData.edges) return;

            const nodes = latestData.nodes;
            const edges = latestData.edges;

            // Apply force-directed layout simulation
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const forceStrength = 0.1;
            const damping = 0.9;

            // Apply forces
            nodes.forEach(node => {
                // Center force
                const dx = centerX - node.x;
                const dy = centerY - node.y;
                node.vx += dx * forceStrength * 0.01;
                node.vy += dy * forceStrength * 0.01;

                // Repulsion force between nodes
                nodes.forEach(otherNode => {
                    if (node !== otherNode) {
                        const dx = node.x - otherNode.x;
                        const dy = node.y - otherNode.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 0 && distance < 100) {
                            const force = forceStrength / (distance * distance);
                            node.vx += (dx / distance) * force;
                            node.vy += (dy / distance) * force;
                        }
                    }
                });

                // Attraction force for connected nodes
                edges.forEach(edge => {
                    if (edge.source === node.id) {
                        const targetNode = nodes[edge.target];
                        if (targetNode) {
                            const dx = targetNode.x - node.x;
                            const dy = targetNode.y - node.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > 0) {
                                const force = forceStrength * 0.1;
                                node.vx += (dx / distance) * force;
                                node.vy += (dy / distance) * force;
                            }
                        }
                    }
                });

                // Apply damping and update position
                node.vx *= damping;
                node.vy *= damping;
                node.x += node.vx;
                node.y += node.vy;

                // Keep nodes within bounds
                node.x = Math.max(20, Math.min(rect.width - 20, node.x));
                node.y = Math.max(20, Math.min(rect.height - 20, node.y));
            });

            // Draw edges
            edges.forEach(edge => {
                const sourceNode = nodes[edge.source];
                const targetNode = nodes[edge.target];
                if (sourceNode && targetNode) {
                    ctx.strokeStyle = edge.color || 'rgba(102, 126, 234, 0.3)';
                    ctx.lineWidth = edge.weight ? edge.weight / 3 : 1;
                    ctx.beginPath();
                    ctx.moveTo(sourceNode.x, sourceNode.y);
                    ctx.lineTo(targetNode.x, targetNode.y);
                    ctx.stroke();
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                // Node shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillStyle = node.color || '#667eea';
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.size || 6, 0, 2 * Math.PI);
                ctx.fill();

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Node label
                ctx.fillStyle = '#2c3e50';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(node.label || node.id, node.x, node.y - node.size - 8);
            });

            // Draw title
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Force-Directed Layout', rect.width / 2, 20);

            const renderTime = performance.now() - startTime;
            renderTimes.push(renderTime);
            if (renderTimes.length > 10) renderTimes.shift();
        }

        // Update metrics
        function updateMetrics() {
            const now = Date.now();
            const uptime = now - startTime;

            // Update connection status
            const statusEl = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');
            if (isStreaming) {
                statusEl.className = 'status-indicator status-connected';
                statusText.textContent = 'Streaming';
            } else {
                statusEl.className = 'status-indicator status-disconnected';
                statusText.textContent = 'Stopped';
            }

            // Update data rate
            document.getElementById('data-rate').textContent = dataRate.toFixed(1);

            // Update render time
            const avgRenderTime = renderTimes.length > 0
                ? renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length
                : 0;
            document.getElementById('render-time').textContent = avgRenderTime.toFixed(1) + 'ms';

            // Update memory usage (simulated)
            const memoryUsage = (dataPoints.length * 0.001).toFixed(1);
            document.getElementById('memory-usage').textContent = memoryUsage + 'MB';

            // Update total points
            document.getElementById('total-points').textContent = dataPoints.length;

            // Update uptime
            const hours = Math.floor(uptime / 3600000);
            const minutes = Math.floor((uptime % 3600000) / 60000);
            const seconds = Math.floor((uptime % 60000) / 1000);
            document.getElementById('uptime').textContent =
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Logging function
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;

            // Keep only last 50 entries
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Start streaming
        function startStreaming() {
            if (isStreaming) return;

            isStreaming = true;
            startTime = Date.now();
            dataPoints = [];
            renderTimes = [];
            dataRate = 0;
            lastDataTime = Date.now();

            logMessage('üöÄ Starting data stream...', 'success');
            logMessage(`üìä Data source: ${dataSource}`, 'info');
            logMessage(`‚è±Ô∏è Update frequency: ${updateFrequency}ms`, 'info');
            logMessage(`üìà Max data points: ${maxDataPoints}`, 'info');

            streamingInterval = setInterval(() => {
                const newData = generateData();
                dataPoints.push(newData);

                // Keep only recent data points
                if (dataPoints.length > maxDataPoints) {
                    dataPoints.shift();
                }

                // Update data rate
                const now = Date.now();
                const timeDiff = now - lastDataTime;
                dataRate = 1000 / timeDiff;
                lastDataTime = now;

                // Render all charts
                renderLineChart();
                renderBarChart();
                renderScatterChart();
                renderAreaChart();
                renderGraphChart();
                renderForceChart();

                // Update metrics
                updateMetrics();

            }, updateFrequency);

            document.getElementById('start-streaming').disabled = true;
            document.getElementById('stop-streaming').disabled = false;
        }

        // Stop streaming
        function stopStreaming() {
            if (!isStreaming) return;

            isStreaming = false;
            if (streamingInterval) {
                clearInterval(streamingInterval);
                streamingInterval = null;
            }

            logMessage('‚èπÔ∏è Data stream stopped', 'warning');

            document.getElementById('start-streaming').disabled = false;
            document.getElementById('stop-streaming').disabled = true;
        }

        // Event listeners
        document.getElementById('start-streaming').addEventListener('click', startStreaming);
        document.getElementById('stop-streaming').addEventListener('click', stopStreaming);

        document.getElementById('data-source').addEventListener('change', (e) => {
            dataSource = e.target.value;
            logMessage(`üìä Data source changed to: ${dataSource}`, 'info');
        });

        document.getElementById('update-frequency').addEventListener('change', (e) => {
            updateFrequency = parseInt(e.target.value);
            logMessage(`‚è±Ô∏è Update frequency changed to: ${updateFrequency}ms`, 'info');
        });

        document.getElementById('data-points').addEventListener('input', (e) => {
            maxDataPoints = parseInt(e.target.value);
            document.getElementById('data-points-value').textContent = maxDataPoints;
            logMessage(`üìà Max data points changed to: ${maxDataPoints}`, 'info');
        });

        // Initialize
        document.getElementById('stop-streaming').disabled = true;
        logMessage('üéØ Live streaming demo ready', 'success');
        logMessage('üí° Select a data source and click "Start Streaming"', 'info');

        // Update metrics every second
        setInterval(updateMetrics, 1000);

        // Handle window resize
        window.addEventListener('resize', () => {
            setupCanvas(lineChart);
            setupCanvas(barChart);
            setupCanvas(scatterChart);
            setupCanvas(areaChart);
            setupCanvas(graphChart);
            setupCanvas(forceChart);

            if (isStreaming) {
                renderLineChart();
                renderBarChart();
                renderScatterChart();
                renderAreaChart();
                renderGraphChart();
                renderForceChart();
            }
        });
    </script>
</body>
</html>
